"""
Main entry point for the Jira-Confluence Automation FastAPI application.

This module initializes the FastAPI app, sets up the application lifecycle
(lifespan) for managing resources like HTTP clients, configures middleware
for logging and request tracking, defines global exception handlers for
consistent error responses, and registers all the API endpoints.
"""

import logging
import uuid
from contextlib import asynccontextmanager
from typing import Callable, List

import httpx
from fastapi import Depends, FastAPI, Request, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

from src.dependencies import (
    get_api_key,
    get_confluence_issue_updater_service,
    get_https_helper,
    get_safe_confluence_api,
    get_safe_jira_api,
    get_sync_task_orchestrator,
    get_undo_sync_task_orchestrator,
)
from src.exceptions import (
    AutomationError,
    InvalidInputError,
    MissingRequiredDataError,
    ParentIssueNotFoundError,
    SetupError,
    SyncError,
    UndoError,
)
from src.models.data_models import (
    ConfluenceUpdateProjectRequest,
    SyncProjectResponse,
    SyncRequest,
    SyncTaskResponse,
    UndoRequestItem,
    UndoSyncTaskResponse,
)
from src.utils.logging_config import endpoint_var, request_id_var, setup_logging

logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Manages the application's lifespan events for resource management.

    This asynchronous context manager handles the setup and teardown of
    application-level resources. On startup, it initializes logging and the
    shared `httpx.AsyncClient`. On shutdown, it ensures the client is closed
    gracefully to release network connections.

    Args:
        app (FastAPI): The FastAPI application instance.
    """
    setup_logging()
    logger.info("Application starting up...")
    http_helper = get_https_helper()
    try:
        http_helper.client = httpx.AsyncClient(
            verify=getattr(http_helper, "_verify_ssl", True), cookies=httpx.Cookies()
        )
    except Exception:
        logger.exception("Error creating httpx client during app startup.")

    yield

    logger.info("Application shutting down...")
    if (
        hasattr(http_helper, "client")
        and http_helper.client
        and hasattr(http_helper.client, "aclose")
    ):
        await http_helper.client.aclose()
    logger.info("Application shutdown complete.")


app = FastAPI(
    title="Jira-Confluence Automation API",
    description="API for synchronizing tasks from Confluence to Jira",
    version="1.0.0",
    lifespan=lifespan,
)


class LoggingMiddleware(BaseHTTPMiddleware):
    """
    Middleware to inject a unique request ID and endpoint path into logs.

    This middleware ensures that every log message generated during a request
    is tagged with a unique ID, making it easier to trace the execution path
    of a single API call.
    """

    async def dispatch(self, request: Request, call_next: Callable):
        """
        Processes each incoming request to add logging context. It also serves
        as a final catch-all for unhandled exceptions due to framework limitations.

        Args:
            request (Request): The incoming FastAPI request.
            call_next (Callable): The next middleware or endpoint in the chain.

        Returns:
            Response: The response generated by the endpoint,
            or a JSONResponse on error.
        """
        req_id = uuid.uuid4().hex
        request_id_var.set(req_id)
        endpoint_name = request.url.path
        endpoint_var.set(endpoint_name)

        logger.info(
            f"Request started for user: {request.headers.get('user-agent', 'unknown')}"
        )

        try:
            response = await call_next(request)
            response.headers["X-Request-ID"] = req_id
            logger.info(f"Request finished with status code: {response.status_code}")
            return response
        except Exception:
            # This is the final catch-all. Due to limitations in BaseHTTPMiddleware,
            # this is the only place to reliably catch unhandled exceptions
            # and format a proper 500 response without crashing the server.
            logger.critical("Unhandled exception caught in middleware", exc_info=True)
            return JSONResponse(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                content={"detail": "An unexpected internal server error occurred."},
            )


app.add_middleware(LoggingMiddleware)


@app.exception_handler(InvalidInputError)
async def invalid_input_error_handler(request: Request, exc: InvalidInputError):
    """Handles errors from invalid request body format."""
    logger.warning(f"Invalid input provided: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={"detail": f"Invalid input: {exc}"},
    )


@app.exception_handler(ParentIssueNotFoundError)
async def parent_issue_not_found_error_handler(
    request: Request, exc: ParentIssueNotFoundError
):
    """Handles failure to find a required parent entity (e.g., Work Package)."""
    logger.error(f"A required parent issue was not found: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_404_NOT_FOUND,
        content={"detail": str(exc)},
    )


@app.exception_handler(SetupError)
async def setup_error_handler(request: Request, exc: SetupError):
    """Handles generic errors during the pre-processing/setup phase."""
    logger.warning(f"Request setup failed: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={"detail": f"Request setup failed: {exc}"},
    )


@app.exception_handler(SyncError)
async def sync_error_handler(request: Request, exc: SyncError):
    """Handles errors during the main synchronization workflow."""
    # This indicates a backend failure during a complex operation.
    logger.error(f"Synchronization process error: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": f"An error occurred during synchronization: {exc}"},
    )


@app.exception_handler(UndoError)
async def undo_error_handler(request: Request, exc: UndoError):
    """Handles errors specifically from the undo workflow."""
    logger.error(f"Undo process error: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": f"An error occurred during the undo process: {exc}"},
    )


@app.exception_handler(MissingRequiredDataError)
async def missing_data_exception_handler(
    request: Request, exc: MissingRequiredDataError
):
    """Handles `MissingRequiredDataError` exceptions globally."""
    logger.warning(f"Missing required data: {exc}")
    return JSONResponse(
        status_code=status.HTTP_404_NOT_FOUND,
        content={"detail": str(exc)},
    )


@app.exception_handler(AutomationError)
async def general_automation_error_handler(request: Request, exc: AutomationError):
    """A final catch-all for any other application-specific errors."""
    logger.critical(f"An unexpected automation error occurred: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": f"An unexpected internal error occurred: {exc}"},
    )


@app.post(
    "/sync_task",
    summary="Synchronize Confluence tasks to Jira",
    response_model=SyncTaskResponse,
    dependencies=[Depends(get_api_key)],
)
async def sync_task(
    request: SyncRequest,
    sync_orchestrator=Depends(get_sync_task_orchestrator),
):
    """
    Initiates the synchronization of tasks from Confluence pages to Jira.

    This endpoint processes a list of Confluence page URLs, finds all
    incomplete tasks within them and their descendants, and creates
    corresponding tasks in Jira.

    Args:
        request (SyncRequest): The request body containing the URLs and context.
        sync_orchestrator: The dependency-injected orchestrator service.

    Returns:
        SyncTaskResponse: The results of the synchronization, including a request
                          ID and a list of processed tasks.
    """
    logger.info(
        f"Received /sync_task request for user: {request.context.request_user} "
        f"with {len(request.confluence_page_urls)} URLs."
    )

    sync_input = request.model_dump()
    response_results_objects = await sync_orchestrator.run(sync_input, request.context)
    response_results = [res.to_dict() for res in response_results_objects]

    if response_results:
        logger.info(f"Sync run completed. Processed {len(response_results)} tasks.")
    else:
        logger.info("Sync run completed, but no actionable tasks were processed.")

    return SyncTaskResponse(request_id=request_id_var.get(), results=response_results)


@app.post(
    "/undo_sync_task",
    summary="Undo a previous synchronization run",
    response_model=UndoSyncTaskResponse,
    dependencies=[Depends(get_api_key)],
)
async def undo_sync_task(
    undo_data: List[UndoRequestItem],
    undo_orchestrator=Depends(get_undo_sync_task_orchestrator),
):
    """
    Reverts the actions from a previous synchronization run.

    This endpoint takes the results from a `/sync_task` call and uses them
    to transition the newly created Jira issues and roll back the corresponding
    Confluence pages to their original state.

    Args:
        undo_data (List[UndoRequestItem]): A list of result items from a
                                            previous sync operation.
        undo_orchestrator: The dependency-injected undo orchestrator service.

    Returns:
        UndoSyncTaskResponse: A confirmation message and request ID.
    """
    user = undo_data[0].request_user if undo_data else "unknown"
    logger.info(
        f"Received /undo_sync_task request for user {user} with {len(undo_data)} items."
    )

    await undo_orchestrator.run([item.model_dump(by_alias=True) for item in undo_data])

    logger.info("Undo run completed successfully.")
    return UndoSyncTaskResponse(
        request_id=request_id_var.get(),
        detail="Undo operation completed successfully.",
    )


@app.post(
    "/sync_project",
    summary="Update embedded Jira project issues on Confluence pages",
    response_model=SyncProjectResponse,
    dependencies=[Depends(get_api_key)],
)
async def update_confluence_project(
    request: ConfluenceUpdateProjectRequest,
    confluence_issue_updater_service=Depends(get_confluence_issue_updater_service),
):
    """
    Updates existing Jira issue macros within a Confluence page hierarchy.

    This is used to synchronize project and phase information from a root
    Jira issue down through a tree of Confluence pages.

    Args:
        request (ConfluenceUpdateProjectRequest): The request details.
        confluence_issue_updater_service: The injected updater service.

    Returns:
        SyncProjectResponse: A summary of the pages that were updated.
    """
    logger.info(
        f"Received /sync_project request for user {request.request_user} on root URL: "
        f"{request.root_confluence_page_url}"
    )

    updated_pages_summary = await confluence_issue_updater_service.update_confluence_hierarchy_with_new_jira_project(  # noqa: E501
        root_confluence_page_url=request.root_confluence_page_url,
        root_project_issue_key=request.root_project_issue_key,
        project_issue_type_id=request.project_issue_type_id,
        phase_issue_type_id=request.phase_issue_type_id,
    )

    if updated_pages_summary:
        logger.info(
            f"Update process completed. Modified {len(updated_pages_summary)} pages."
        )
    else:
        logger.info("Update process completed, but no pages were modified.")

    return SyncProjectResponse(
        request_id=request_id_var.get(), results=updated_pages_summary
    )


@app.get("/", include_in_schema=False)
async def read_root():
    """Provides a simple welcome message at the root URL."""
    return {
        """message": "Welcome to the Jira-Confluence Automation API.
        Visit /docs for API documentation."""
    }


@app.get("/health", status_code=status.HTTP_200_OK)
async def health_check():
    """
    Provides a liveness probe endpoint.

    This check confirms that the application process is running and able to
    respond to requests.
    """
    return {"status": "ok", "detail": "Application is alive."}


@app.get("/ready", status_code=status.HTTP_200_OK)
async def readiness_check(
    jira_api_dep=Depends(get_safe_jira_api),
    confluence_api_dep=Depends(get_safe_confluence_api),
):
    """
    Provides a readiness probe endpoint.

    This check verifies that the application can connect to its external
    dependencies (Jira and Confluence) and is ready to serve traffic.

    Args:
        jira_api_dep: Injected Jira API client.
        confluence_api_dep: Injected Confluence API client.

    Returns:
        A dictionary indicating the readiness status.
    """
    logger.info("Performing readiness check...")
    await jira_api_dep.get_current_user()
    logger.info("Jira API is reachable and authenticated.")
    await confluence_api_dep.get_all_spaces()
    logger.info("Confluence API is reachable and authenticated.")
    return {"status": "ready", "detail": "Application and dependencies are ready."}
